#version 430 core

// We'll process the matrices in chunks (workgroups)
// A local size of 16x16 = 256 threads per workgroup is a good starting point
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Buffers to hold our matrix data
layout(std430, binding = 0) buffer MatrixA { float A[]; };
layout(std430, binding = 1) buffer MatrixB { float B[]; };
layout(std430, binding = 2) buffer ResultMatrix { float C[]; };

// Uniforms to pass matrix dimensions from C++
uniform int u_A_rows;
uniform int u_A_cols; // Also B_rows
uniform int u_B_cols;

void main() {
    // Identify the position of the current thread in the output matrix C
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

    // Boundary check to avoid writing out of bounds if the matrix
    // dimensions aren't a multiple of the local_size
    if (pos.x >= u_B_cols || pos.y >= u_A_rows) {
        return;
    }

    float sum = 0.0;
    // Iterate through the row of A and column of B
    for (int i = 0; i < u_A_cols; ++i) {
        // A is row-major: index = row * num_cols + col
        float a = A[pos.y * u_A_cols + i];
        // B is row-major: index = row * num_cols + col
        float b = B[i * u_B_cols + pos.x];
        sum += a * b;
    }

    // Write the result to the output matrix C
    C[pos.y * u_B_cols + pos.x] = sum;
}