#version 430 core
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Note the bindings are the same as the original matmul shader
layout(std430, binding = 0) buffer MatrixA { float A[]; };
layout(std430, binding = 1) buffer MatrixB { float B[]; };
layout(std430, binding = 2) buffer ResultMatrix { float C[]; };

// Note the dimensions passed in are for the ORIGINAL matrices
uniform int u_A_rows; // original rows of A
uniform int u_A_cols; // original cols of A
uniform int u_B_cols; // original cols of B

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

    // Output matrix C has dimensions: (A_cols x B_cols)
    if (pos.x >= u_B_cols || pos.y >= u_A_cols) {
        return;
    }

    float sum = 0.0;
    // The loop runs over the rows of the original A matrix
    for (int i = 0; i < u_A_rows; ++i) {
        // Access A as if it's transposed: A[col][row] -> A[i * A_cols + pos.y]
        float a = A[i * u_A_cols + pos.y];
        // Access B normally
        float b = B[i * u_B_cols + pos.x];
        sum += a * b;
    }

    C[pos.y * u_B_cols + pos.x] = sum;
}